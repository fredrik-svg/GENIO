<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Administration – Pi5 Röstassistent</title>
  <style>
    :root {
      color-scheme: dark;
      --card-bg: rgba(16, 29, 52, 0.92);
      --card-border: rgba(37, 54, 89, 0.9);
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: radial-gradient(circle at top, #14213d, #0b1220);
      color: #eef2ff;
    }
    a { color: inherit; }
    .wrap {
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 32px 24px 48px;
      max-width: 1000px;
      margin: 0 auto;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    .title {
      font-size: 34px;
      margin: 0;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      padding: 12px 20px;
      border-radius: 14px;
      background: #1f2a44;
      border: 2px solid #3c4a6b;
      color: #fff;
      cursor: pointer;
      text-decoration: none;
      transition: transform 0.1s ease;
    }
    .btn:active { transform: scale(0.98); }
    .btn.danger { background: #51222d; border-color: #823648; }
    .btn.secondary { background: #13233d; border-color: #2a3b5f; }
    .card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 22px;
      padding: 26px;
      box-shadow: 0 25px 45px rgba(0, 0, 0, 0.25);
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .card h2 { margin: 0; font-size: 24px; }
    .helper { margin: 0; opacity: 0.85; }
    label { display: block; font-weight: 600; margin-bottom: 8px; }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1 1 220px;
    }
    .field input,
    .field select,
    .field textarea {
      padding: 14px 16px;
      border-radius: 14px;
      border: 2px solid #3c4a6b;
      background: rgba(15, 26, 47, 0.9);
      color: #eef2ff;
      font-size: 16px;
      font-family: inherit;
    }
    .field small {
      font-size: 14px;
      opacity: 0.75;
    }
    .audio-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px 0;
    }
    .audio-group + .audio-group {
      border-top: 1px solid rgba(76, 101, 150, 0.3);
      margin-top: 14px;
      padding-top: 24px;
    }
    .audio-group h3 {
      margin: 0;
      font-size: 20px;
    }
    .field input[type="color"] {
      padding: 0;
      height: 48px;
      cursor: pointer;
    }
    .grid {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
    }
    .name-preview {
      font-size: 22px;
      font-weight: 600;
      padding: 14px 18px;
      border-radius: 14px;
      background: rgba(18, 36, 70, 0.9);
      border: 1px solid rgba(76, 101, 150, 0.6);
    }
    .name-options {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .name-options button {
      font-size: 14px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid rgba(92, 123, 184, 0.7);
      background: rgba(25, 45, 82, 0.85);
      color: inherit;
      cursor: pointer;
    }
    .name-options button:hover { background: rgba(40, 66, 118, 0.9); }
    .status { font-size: 16px; opacity: 0.9; }
    .log {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .log-entry {
      padding: 16px 18px;
      border-radius: 16px;
      background: #132f3d;
      border: 1px solid #214a61;
      line-height: 1.4;
      font-size: 16px;
    }
    .log-entry.success { border-color: #1b7750; background: #12392d; }
    .log-entry.error { border-color: #7a2c2c; background: #3f1b22; }
    .log-entry small {
      display: block;
      margin-top: 8px;
      opacity: 0.75;
    }
    .lan-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .lan-group h3 {
      margin: 0;
      font-size: 18px;
    }
    .link-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .link-item {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(19, 36, 63, 0.9);
      border: 1px solid rgba(62, 96, 146, 0.55);
    }
    .link-item a {
      color: #9bc9ff;
      font-weight: 600;
      text-decoration: none;
      word-break: break-all;
      flex: 1 1 220px;
    }
    .link-item a:hover {
      text-decoration: underline;
    }
    .copy-btn {
      background: rgba(30, 55, 94, 0.95);
      border: 1px solid rgba(90, 128, 185, 0.7);
      color: #eef2ff;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    .copy-btn:active {
      transform: scale(0.97);
    }
    .display-targets {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 18px;
      padding: 18px;
      border-radius: 16px;
      background: rgba(15, 30, 55, 0.6);
      border: 1px solid rgba(62, 96, 146, 0.4);
    }
    .display-targets h3 {
      margin: 0;
      font-size: 18px;
    }
    .display-targets-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .display-targets-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(18, 36, 70, 0.65);
      border: 1px solid rgba(62, 96, 146, 0.45);
    }
    .display-targets-title {
      font-weight: 600;
      font-size: 16px;
    }
    .display-targets-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }
    .display-action-btn {
      background: rgba(30, 55, 94, 0.95);
      border: 1px solid rgba(90, 128, 185, 0.7);
      color: #eef2ff;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.1s ease, background 0.15s ease;
    }
    .display-action-btn:hover {
      background: rgba(40, 70, 115, 0.95);
    }
    .display-action-btn:active {
      transform: scale(0.97);
    }
    .display-targets-monitors {
      margin: 0;
      padding-left: 20px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .display-targets-monitors li {
      font-size: 14px;
      opacity: 0.85;
    }
    .display-targets-empty {
      margin: 0;
      font-size: 14px;
      opacity: 0.8;
    }
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      font-weight: 500;
    }
    .checkbox-label input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }
    .checkbox-text {
      user-select: none;
    }
    @media (max-width: 720px) {
      .wrap { padding: 24px 16px 40px; }
      header { justify-content: center; }
      .btn { width: 100%; }
      .link-item {
        flex-direction: column;
        align-items: stretch;
      }
      .copy-btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1 class="title">Administration</h1>
      <a class="btn secondary" href="/">⬅ Tillbaka till assistenten</a>
    </header>

    <div class="card" id="appearance-card">
      <div>
        <h2>Bygg assistentens identitet</h2>
        <p class="helper">Sätt namn, bakgrund, typsnitt och färger som gäller för startsidan. Förhandsgranska namnet nedan.</p>
      </div>
      <form id="appearance-form">
        <div class="grid">
          <div class="field">
            <label for="name-prefix">Prefix</label>
            <input id="name-prefix" name="name-prefix" type="text" placeholder="t.ex. Team" />
          </div>
          <div class="field">
            <label for="name-core">Huvudnamn</label>
            <input id="name-core" name="name-core" type="text" placeholder="t.ex. Genio" />
          </div>
          <div class="field">
            <label for="name-suffix">Suffix</label>
            <input id="name-suffix" name="name-suffix" type="text" placeholder="t.ex. AI" />
          </div>
        </div>
        <div class="name-options" aria-label="Namnsförslag">
          <span>Snabbval:</span>
          <button type="button" data-name-part="prefix" data-value="Team">Team</button>
          <button type="button" data-name-part="prefix" data-value="Projekt">Projekt</button>
          <button type="button" data-name-part="core" data-value="Genio">Genio</button>
          <button type="button" data-name-part="core" data-value="Kompis">Kompis</button>
          <button type="button" data-name-part="core" data-value="Vision">Vision</button>
          <button type="button" data-name-part="suffix" data-value="AI">AI</button>
          <button type="button" data-name-part="suffix" data-value="Assist">Assist</button>
          <button type="button" data-name-part="suffix" data-value="Hub">Hub</button>
        </div>
        <div class="field">
          <label for="assistant-name">Resultat</label>
          <input id="assistant-name" name="assistant-name" type="text" placeholder="Skriv fritt eller använd byggaren" />
        </div>
        <div class="name-preview">Förhandsvisning: <span id="assistant-preview">Pi5 Röstassistent</span></div>
        <hr />
        <div class="grid">
          <div class="field">
            <label for="background-image">Bakgrundsbild</label>
            <input id="background-image" name="background-image" type="text" placeholder="https://.../bild.jpg" />
            <input id="background-upload" name="background-upload" type="file" accept="image/*" />
            <small id="background-upload-feedback">Ange en URL eller välj en bild från datorn (max 6 MB).</small>
          </div>
          <div class="field">
            <label for="font-family">Typsnitt</label>
            <input id="font-family" name="font-family" type="text" list="font-options" placeholder="system-ui, sans-serif" />
            <datalist id="font-options">
              <option value="system-ui, -apple-system, 'Segoe UI', Roboto, Arial"></option>
              <option value="'Poppins', 'Segoe UI', sans-serif"></option>
              <option value="'Montserrat', 'Segoe UI', sans-serif"></option>
              <option value="'Fira Sans', 'Segoe UI', sans-serif"></option>
              <option value="'Merriweather', Georgia, serif"></option>
            </datalist>
          </div>
        </div>
        <div class="grid">
          <div class="field">
            <label for="primary-button-color">Primär knapfärg</label>
            <input id="primary-button-color" name="primary-button-color" type="color" value="#1f2a44" />
          </div>
          <div class="field">
            <label for="secondary-button-color">Sekundär knapfärg</label>
            <input id="secondary-button-color" name="secondary-button-color" type="color" value="#13233d" />
          </div>
          <div class="field">
            <label for="button-text-color">Textfärg på knappar</label>
            <input id="button-text-color" name="button-text-color" type="color" value="#ffffff" />
          </div>
        </div>
        <div class="grid">
          <button class="btn" id="appearance-submit" type="submit">Spara utseende</button>
        </div>
      </form>
      <div class="status" id="appearance-status">Inställningarna gäller för startsidan.</div>
    </div>

    <div class="card" id="lan-card">
      <div>
        <h2>Öppna från andra enheter</h2>
        <p class="helper" id="lan-status">Söker tillgängliga adresser på nätverket ...</p>
      </div>
      <div class="lan-group" aria-live="polite">
        <h3>Administration</h3>
        <ul class="link-list" id="lan-admin-list"></ul>
      </div>
      <div class="lan-group" aria-live="polite">
        <h3>Visningsläge</h3>
        <ul class="link-list" id="lan-display-list"></ul>
      </div>
    </div>

    <div class="card" id="display-card">
      <div>
        <h2>Välj skärmar</h2>
        <p class="helper" id="display-helper">Söker skärmar ...</p>
      </div>
      <div class="display-targets" id="display-targets" aria-live="polite">
        <h3>Tillgängliga skärmar</h3>
        <div id="display-targets-content">
          <p class="display-targets-empty">Söker efter anslutna skärmar ...</p>
        </div>
      </div>
      <form id="display-form">
        <div class="audio-group" id="assistant-display-group">
          <h3>Assistent</h3>
          <div class="field">
            <label for="assistant-display-select">Skärm</label>
            <select id="assistant-display-select" name="assistant-display">
              <option value="auto">Systemets standard</option>
              <option value="manual">Ange manuellt värde ...</option>
            </select>
            <small>Välj X11-display (t.ex. :0) eller ange manuellt värde.</small>
          </div>
          <div class="field" id="assistant-display-manual-field" style="display:none;">
            <label for="assistant-display-manual">Manuell skärm</label>
            <input id="assistant-display-manual" type="text" placeholder=":0" />
            <small>Ange exakt displaynamn, t.ex. :0.1 eller ett Wayland-namn.</small>
          </div>
          <div class="status" id="assistant-display-status">Assistenten använder systemets standarddisplay.</div>
        </div>
        <div class="audio-group" id="presentation-display-group">
          <h3>Visningsläge</h3>
          <div class="field">
            <label for="presentation-display-select">Skärm</label>
            <select id="presentation-display-select" name="presentation-display">
              <option value="auto">Systemets standard</option>
              <option value="manual">Ange manuellt värde ...</option>
            </select>
            <small>Välj skärm för visningsläget.</small>
          </div>
          <div class="field" id="presentation-display-manual-field" style="display:none;">
            <label for="presentation-display-manual">Manuell skärm</label>
            <input id="presentation-display-manual" type="text" placeholder=":0.1" />
            <small>Ange exakt displaynamn, t.ex. :0.1.</small>
          </div>
          <div class="status" id="presentation-display-status">Visningsläget använder systemets standarddisplay.</div>
        </div>
        <div class="grid">
          <button class="btn secondary" type="button" id="display-refresh">Uppdatera lista</button>
          <button class="btn" type="submit" id="display-save">Spara skärmar</button>
        </div>
      </form>
      <div class="status" id="display-status"></div>
    </div>

    <div class="card" id="audio-card">
      <div>
        <h2>Välj ljudenheter</h2>
        <p class="helper">Ställ in vilka enheter som används för inspelning och uppspelning.</p>
      </div>
      <form id="audio-form">
        <div class="audio-group" id="audio-input-group">
          <h3>Inspelning (mikrofon)</h3>
          <div class="field">
            <label for="audio-input-select">Inspelningskälla</label>
            <select id="audio-input-select" name="input-device">
              <option value="auto">Systemets standard</option>
              <option value="manual">Ange manuellt värde ...</option>
            </select>
            <small>Om din mikrofon inte visas kan du ange namn eller index manuellt.</small>
          </div>
          <div class="field" id="audio-input-custom-field" style="display:none;">
            <label for="audio-input-custom">Manuell ljudkälla</label>
            <input id="audio-input-custom" name="audio-input-custom" type="text" placeholder="t.ex. hw:2,0" />
            <small>Ange exakt namn, index eller ALSA-sträng.</small>
          </div>
          <div class="status" id="audio-input-status">Ingen specifik ljudkälla vald – systemets standard används.</div>
        </div>
        <div class="audio-group" id="audio-output-group">
          <h3>Uppspelning (högtalare)</h3>
          <div class="field">
            <label for="audio-output-select">Uppspelningsenhet</label>
            <select id="audio-output-select" name="output-device">
              <option value="auto">Systemets standard</option>
              <option value="manual">Ange manuellt värde ...</option>
            </select>
            <small>Om din högtalare inte visas kan du ange namn eller index manuellt.</small>
          </div>
          <div class="field" id="audio-output-custom-field" style="display:none;">
            <label for="audio-output-custom">Manuell ljudutgång</label>
            <input id="audio-output-custom" name="audio-output-custom" type="text" placeholder="t.ex. hw:0,0" />
            <small>Ange exakt namn, index eller ALSA-sträng.</small>
          </div>
          <div class="status" id="audio-output-status">Ingen specifik ljudutgång vald – systemets standard används.</div>
        </div>
        <div class="grid">
          <button class="btn secondary" type="button" id="audio-refresh">Uppdatera listor</button>
          <button class="btn" type="submit" id="audio-save">Spara ljudenheter</button>
        </div>
      </form>
    </div>

    <div class="card" id="wake-word-card">
      <div>
        <h2>Wake Word-inställningar</h2>
        <p class="helper">Konfigurera röstaktivering för handsfree-användning.</p>
      </div>
      <form id="wake-word-form">
        <div class="field">
          <label class="checkbox-label">
            <input type="checkbox" id="wake-word-enabled" name="wake-word-enabled" />
            <span class="checkbox-text">Aktivera wake word-detektering</span>
          </label>
          <small>När aktiverat lyssnar systemet kontinuerligt efter konfigurerade wake words.</small>
        </div>
        <div class="field" id="wake-words-field">
          <label for="wake-words-input">Wake words (kommaseparerade)</label>
          <input id="wake-words-input" name="wake-words" type="text" placeholder="hej genio, genio, hej assistant" />
          <small>Ange de ord eller fraser som ska aktivera assistenten, separerade med komman.</small>
        </div>
        <div class="grid">
          <div class="field">
            <label for="wake-word-timeout">Timeout (sekunder)</label>
            <input id="wake-word-timeout" name="wake-word-timeout" type="number" min="1" max="10" step="0.1" value="5.0" />
            <small>Hur länge systemet lyssnar per detekteringsförsök.</small>
          </div>
          <div class="field">
            <label for="wake-word-cooldown">Cooldown (sekunder)</label>
            <input id="wake-word-cooldown" name="wake-word-cooldown" type="number" min="0.1" max="5" step="0.1" value="1.0" />
            <small>Paus mellan wake word-detekteringar.</small>
          </div>
        </div>
        <div class="grid">
          <button class="btn" type="submit" id="wake-word-save">Spara wake word-inställningar</button>
        </div>
      </form>
      <div class="status" id="wake-word-status"></div>
    </div>

    <div class="card">
      <div>
        <h2>Hantera kunskapsbas (RAG)</h2>
        <p class="helper">Indexera nya källor eller rensa befintligt innehåll.</p>
      </div>
      <form class="grid" id="rag-form">
        <div class="field" style="flex:1 1 100%">
          <label for="rag-input">Källor att indexera</label>
          <textarea
            class="rag-input"
            id="rag-input"
            name="sources"
            rows="4"
            placeholder="https://exempel.se/dokument.pdf&#10;/home/pi/dokument.txt"
          ></textarea>
        </div>
        <button class="btn" type="submit" id="rag-submit">Indexera källor</button>
        <button class="btn danger" type="button" id="rag-reset">Rensa kunskapsbasen</button>
      </form>
      <div class="status" id="status">Redo.</div>
      <div class="log" id="log" aria-live="polite"></div>
    </div>

    <div class="card" id="mcp-card">
      <div>
        <h2>MCP-serverkopplingar</h2>
        <p class="helper">Aktivera och hantera MCP (Model Context Protocol) servrar för att koppla ihop assistenten med externa verktyg.</p>
      </div>
      <div class="field">
        <label class="checkbox-label">
          <input type="checkbox" id="mcp-enabled" />
          <span class="checkbox-text">Aktivera MCP</span>
        </label>
        <small>När MCP är aktiverat kan assistenten använda verktyg från konfigurerade servrar.</small>
      </div>
      <div id="mcp-servers-section" style="display:none;">
        <h3 style="margin-top:20px; font-size:20px;">Konfigurerade servrar</h3>
        <div id="mcp-servers-list" style="display:flex; flex-direction:column; gap:16px; margin-top:12px;">
          <p style="opacity:0.75;">Inga servrar konfigurerade.</p>
        </div>
        <h3 style="margin-top:24px; font-size:20px;">Lägg till ny server</h3>
        <form id="mcp-add-server-form">
          <div class="grid">
            <div class="field">
              <label for="mcp-server-name">Servernamn</label>
              <input id="mcp-server-name" type="text" placeholder="t.ex. filesystem" required />
              <small>Unikt namn för servern.</small>
            </div>
            <div class="field">
              <label for="mcp-server-command">Kommando</label>
              <input id="mcp-server-command" type="text" placeholder="t.ex. npx" required />
              <small>Kommando för att starta servern.</small>
            </div>
          </div>
          <div class="field" style="margin-top:12px;">
            <label for="mcp-server-args">Argument (en per rad)</label>
            <textarea id="mcp-server-args" rows="3" placeholder="-y&#10;@modelcontextprotocol/server-filesystem&#10;/path/to/files"></textarea>
            <small>Kommandoargument, ett per rad.</small>
          </div>
          <div class="field" style="margin-top:12px;">
            <label for="mcp-server-env">Miljövariabler (JSON)</label>
            <textarea id="mcp-server-env" rows="2" placeholder='{"GITHUB_TOKEN": "your-token"}'></textarea>
            <small>Valfria miljövariabler i JSON-format.</small>
          </div>
          <button class="btn" type="submit" style="margin-top:12px;">Lägg till server</button>
        </form>
      </div>
      <div class="grid" style="margin-top:18px;">
        <button class="btn" id="mcp-save" type="button">Spara MCP-inställningar</button>
      </div>
      <div class="status" id="mcp-status">Hämtar MCP-inställningar ...</div>
    </div>
  </div>

  <script>
    const appearanceForm = document.getElementById('appearance-form');
    const namePrefix = document.getElementById('name-prefix');
    const nameCore = document.getElementById('name-core');
    const nameSuffix = document.getElementById('name-suffix');
    const assistantNameInput = document.getElementById('assistant-name');
    const assistantPreview = document.getElementById('assistant-preview');
    const backgroundInput = document.getElementById('background-image');
    const backgroundUploadInput = document.getElementById('background-upload');
    const backgroundUploadFeedback = document.getElementById('background-upload-feedback');
    const fontInput = document.getElementById('font-family');
    const primaryColorInput = document.getElementById('primary-button-color');
    const secondaryColorInput = document.getElementById('secondary-button-color');
    const buttonTextColorInput = document.getElementById('button-text-color');
    const appearanceStatus = document.getElementById('appearance-status');
    const ragForm = document.getElementById('rag-form');
    const ragInput = document.getElementById('rag-input');
    const ragSubmit = document.getElementById('rag-submit');
    const ragReset = document.getElementById('rag-reset');
    const statusEl = document.getElementById('status');
    const log = document.getElementById('log');
    const lanStatus = document.getElementById('lan-status');
    const lanAdminList = document.getElementById('lan-admin-list');
    const lanDisplayList = document.getElementById('lan-display-list');
    const displayForm = document.getElementById('display-form');
    const displayHelper = document.getElementById('display-helper');
    const displayStatus = document.getElementById('display-status');
    const displayTargetsContainer = document.getElementById('display-targets');
    const displayTargetsContent = document.getElementById('display-targets-content');
    const displayRefreshBtn = document.getElementById('display-refresh');
    const displayControls = {
      assistant: {
        select: document.getElementById('assistant-display-select'),
        manualField: document.getElementById('assistant-display-manual-field'),
        manualInput: document.getElementById('assistant-display-manual'),
        status: document.getElementById('assistant-display-status'),
        defaultStatus: 'Assistenten använder systemets standarddisplay.',
        manualOption: null,
        manualDefaultLabel: ''
      },
      display: {
        select: document.getElementById('presentation-display-select'),
        manualField: document.getElementById('presentation-display-manual-field'),
        manualInput: document.getElementById('presentation-display-manual'),
        status: document.getElementById('presentation-display-status'),
        defaultStatus: 'Visningsläget använder systemets standarddisplay.',
        manualOption: null,
        manualDefaultLabel: ''
      }
    };
    const displayTargetsState = { list: [] };
    let lastDisplaySettings = null;
    const audioForm = document.getElementById('audio-form');
    const audioControls = {
      input: {
        kind: 'input',
        select: document.getElementById('audio-input-select'),
        manualField: document.getElementById('audio-input-custom-field'),
        manualInput: document.getElementById('audio-input-custom'),
        status: document.getElementById('audio-input-status'),
        defaultStatus: 'Ingen specifik ljudkälla vald – systemets standard används.',
        loadingText: 'Hämtar ljudenheter ...'
      },
      output: {
        kind: 'output',
        select: document.getElementById('audio-output-select'),
        manualField: document.getElementById('audio-output-custom-field'),
        manualInput: document.getElementById('audio-output-custom'),
        status: document.getElementById('audio-output-status'),
        defaultStatus: 'Ingen specifik ljudutgång vald – systemets standard används.',
        loadingText: 'Hämtar ljudutgångar ...'
      }
    };
    const audioRefreshBtn = document.getElementById('audio-refresh');
    const wakeWordForm = document.getElementById('wake-word-form');
    const wakeWordEnabled = document.getElementById('wake-word-enabled');
    const wakeWordsInput = document.getElementById('wake-words-input');
    const wakeWordTimeout = document.getElementById('wake-word-timeout');
    const wakeWordCooldown = document.getElementById('wake-word-cooldown');
    const wakeWordStatus = document.getElementById('wake-word-status');
    const backgroundUploadDefaultText = backgroundUploadFeedback ? backgroundUploadFeedback.textContent : '';
    let lanStatusDefault = lanStatus ? lanStatus.textContent : '';
    const clipboardAvailable = !!(navigator.clipboard && typeof navigator.clipboard.writeText === 'function');

    const defaultSettings = {
      assistantName: 'Pi5 Röstassistent',
      backgroundImage: '',
      fontFamily: "system-ui, -apple-system, 'Segoe UI', Roboto, Arial",
      primaryButtonColor: '#1f2a44',
      secondaryButtonColor: '#13233d',
      buttonTextColor: '#ffffff'
    };

    function setLanStatus(text, persist = false){
      if(!lanStatus){
        return;
      }
      lanStatus.textContent = text;
      if(persist){
        lanStatusDefault = text;
      }
    }

    function flashLanStatus(text){
      if(!lanStatus){
        return;
      }
      lanStatus.textContent = text;
      window.setTimeout(() => {
        if(lanStatus){
          lanStatus.textContent = lanStatusDefault || '';
        }
      }, 3200);
    }

    function setDisplayStatus(text){
      if(displayStatus){
        displayStatus.textContent = text || '';
      }
    }

    function toggleDisplayManualField(fieldEl, show){
      if(!fieldEl){
        return;
      }
      fieldEl.style.display = show ? '' : 'none';
    }

    function formatRefreshLabel(value){
      if(typeof value !== 'number' || Number.isNaN(value) || !Number.isFinite(value) || value <= 0){
        return '';
      }
      let refresh = value;
      if(refresh > 1000){
        refresh = refresh / 1000;
      }
      const rounded = Math.round(refresh * 10) / 10;
      if(Math.abs(rounded - Math.round(rounded)) < 1e-6){
        return `${Math.round(rounded)} Hz`;
      }
      return `${rounded.toFixed(1)} Hz`;
    }

    function formatDisplayMonitor(monitor){
      if(!monitor || typeof monitor !== 'object'){
        return '';
      }

      const index = Number.isInteger(monitor.index) ? monitor.index : null;
      const isPrimary = monitor.primary === true;
      const isActive = monitor.active === true;
      const name = typeof monitor.name === 'string' ? monitor.name.trim() : '';
      const description = typeof monitor.description === 'string' ? monitor.description.trim() : '';
      const make = typeof monitor.make === 'string' ? monitor.make.trim() : '';
      const model = typeof monitor.model === 'string' ? monitor.model.trim() : '';

      const baseName = name || description || `${make}${model ? ` ${model}` : ''}`.trim();
      let labelCore = baseName;
      if(index !== null){
        if(labelCore){
          labelCore = `Skärm ${index + 1}: ${labelCore}`;
        } else {
          labelCore = `Skärm ${index + 1}`;
        }
      }
      if(!labelCore){
        labelCore = 'Skärm';
      }

      const annotations = [];
      if(isPrimary){
        annotations.push('primär');
      }
      if(isActive && !isPrimary){
        annotations.push('aktiv');
      }

      let label = labelCore;
      if(annotations.length){
        label = `${label} (${annotations.join(', ')})`;
      }

      const details = [];
      const makeModel = [make, model].filter(Boolean).join(' ');
      if(makeModel && !label.includes(makeModel)){
        details.push(makeModel);
      }
      const width = typeof monitor.width === 'number' && monitor.width > 0 ? monitor.width : null;
      const height = typeof monitor.height === 'number' && monitor.height > 0 ? monitor.height : null;
      if(width && height){
        details.push(`${width}x${height}`);
      }
      const refresh = typeof monitor.refreshHz === 'number' ? monitor.refreshHz : monitor.refresh;
      const refreshLabel = formatRefreshLabel(refresh);
      if(refreshLabel){
        details.push(refreshLabel);
      }
      const scale = typeof monitor.scale === 'number' && monitor.scale > 0 ? monitor.scale : null;
      if(scale && scale !== 1){
        details.push(`skala ${scale}`);
      }
      if(description && description !== baseName && !details.includes(description)){
        details.push(description);
      }

      return details.length ? `${label} – ${details.join(', ')}` : label;
    }

    function renderDisplayTargetsPreview(){
      if(!displayTargetsContainer || !displayTargetsContent){
        return;
      }
      const targets = Array.isArray(displayTargetsState.list) ? displayTargetsState.list : [];
      displayTargetsContent.innerHTML = '';

      if(!targets.length){
        const empty = document.createElement('p');
        empty.className = 'display-targets-empty';
        empty.textContent = 'Inga skärmar hittades automatiskt – ange värden manuellt vid behov.';
        displayTargetsContent.appendChild(empty);
        return;
      }

      const list = document.createElement('ul');
      list.className = 'display-targets-list';

      targets.forEach((target) => {
        if(!target || typeof target.value !== 'string'){
          return;
        }
        const item = document.createElement('li');
        item.className = 'display-targets-item';

        const title = document.createElement('div');
        title.className = 'display-targets-title';
        const titleText = typeof target.label === 'string' && target.label.trim()
          ? target.label.trim()
          : target.value;
        title.textContent = titleText;
        item.appendChild(title);

        const monitors = Array.isArray(target.monitors) ? target.monitors : [];
        if(monitors.length){
          const monitorList = document.createElement('ul');
          monitorList.className = 'display-targets-monitors';
          monitors.forEach((monitor) => {
            const entry = formatDisplayMonitor(monitor);
            if(!entry){
              return;
            }
            const monitorItem = document.createElement('li');
            monitorItem.textContent = entry;
            monitorList.appendChild(monitorItem);
          });
          if(monitorList.childElementCount){
            item.appendChild(monitorList);
          }
        } else {
          const fallback = document.createElement('p');
          fallback.className = 'display-targets-empty';
          fallback.textContent = target.value;
          item.appendChild(fallback);
        }

        const actions = document.createElement('div');
        actions.className = 'display-targets-actions';

        const setAssistantBtn = document.createElement('button');
        setAssistantBtn.type = 'button';
        setAssistantBtn.className = 'display-action-btn';
        setAssistantBtn.textContent = 'Använd för Assistent';
        setAssistantBtn.title = `Välj ${target.value} för assistentskärm`;
        setAssistantBtn.addEventListener('click', () => {
          setDisplayForControl('assistant', target.value);
        });
        actions.appendChild(setAssistantBtn);

        const setDisplayBtn = document.createElement('button');
        setDisplayBtn.type = 'button';
        setDisplayBtn.className = 'display-action-btn';
        setDisplayBtn.textContent = 'Använd för Visningsläge';
        setDisplayBtn.title = `Välj ${target.value} för visningslägesskärm`;
        setDisplayBtn.addEventListener('click', () => {
          setDisplayForControl('display', target.value);
        });
        actions.appendChild(setDisplayBtn);

        item.appendChild(actions);
        list.appendChild(item);
      });

      if(!list.childElementCount){
        const empty = document.createElement('p');
        empty.className = 'display-targets-empty';
        empty.textContent = 'Inga skärmdetaljer kunde hämtas.';
        displayTargetsContent.appendChild(empty);
        return;
      }

      displayTargetsContent.appendChild(list);
    }

    function setDisplayForControl(controlKey, displayValue){
      const ctrl = displayControls[controlKey];
      if(!ctrl || !ctrl.select){
        return;
      }

      const options = Array.from(ctrl.select.options || []);
      const matchingOption = options.find(opt => opt.value === displayValue);

      if(matchingOption){
        ctrl.select.value = displayValue;
        toggleDisplayManualField(ctrl.manualField, false);
        if(ctrl.manualInput){
          ctrl.manualInput.value = displayValue;
        }
        updateManualOptionLabel(ctrl, '');
      } else {
        ctrl.select.value = 'manual';
        toggleDisplayManualField(ctrl.manualField, true);
        if(ctrl.manualInput){
          ctrl.manualInput.value = displayValue;
          ctrl.manualInput.focus();
        }
        updateManualOptionLabel(ctrl, displayValue);
      }

      const roleName = controlKey === 'assistant' ? 'assistenten' : 'visningsläget';
      if(ctrl.status){
        ctrl.status.textContent = `Vald skärm för ${roleName}: ${displayValue}`;
      }

      window.scrollTo({
        top: displayForm.offsetTop - 20,
        behavior: 'smooth'
      });
    }

    function formatManualLabel(value){
      if(typeof value !== 'string'){
        return '';
      }
      const trimmed = value.trim();
      if(trimmed.length <= 48){
        return trimmed;
      }
      return `${trimmed.slice(0, 45)}…`;
    }

    function updateManualOptionLabel(ctrl, manualValue){
      if(!ctrl || !ctrl.manualOption){
        return;
      }
      const defaultLabel = ctrl.manualDefaultLabel || 'Ange manuellt värde ...';
      const trimmed = typeof manualValue === 'string' ? manualValue.trim() : '';
      if(trimmed){
        const formatted = formatManualLabel(trimmed);
        ctrl.manualOption.textContent = `Manuellt värde – ${formatted}`;
        ctrl.manualOption.title = trimmed;
      } else {
        ctrl.manualOption.textContent = defaultLabel;
        ctrl.manualOption.removeAttribute('title');
      }
    }

    function populateDisplayOptions(ctrl){
      if(!ctrl || !ctrl.select){
        return;
      }
      const selectEl = ctrl.select;
      const previousValue = selectEl.value;
      selectEl.innerHTML = '';

      const autoOption = document.createElement('option');
      autoOption.value = 'auto';
      autoOption.textContent = 'Systemets standard';
      selectEl.appendChild(autoOption);

      const manualOption = document.createElement('option');
      manualOption.value = 'manual';
      const defaultLabel = ctrl.manualDefaultLabel || 'Ange manuellt värde ...';
      manualOption.textContent = defaultLabel;
      selectEl.appendChild(manualOption);
      ctrl.manualOption = manualOption;
      if(!ctrl.manualDefaultLabel){
        ctrl.manualDefaultLabel = defaultLabel;
      }

      const targets = Array.isArray(displayTargetsState.list) ? displayTargetsState.list : [];
      targets.forEach((target) => {
        if(!target || typeof target.value !== 'string'){
          return;
        }
        const option = document.createElement('option');
        option.value = target.value;
        const label = typeof target.label === 'string' && target.label.trim()
          ? target.label.trim()
          : target.value;
        option.textContent = label;
        const monitors = Array.isArray(target.monitors) ? target.monitors : [];
        const summary = monitors
          .map((monitor) => formatDisplayMonitor(monitor))
          .filter((entry) => typeof entry === 'string' && entry.trim())
          .join(' • ');
        option.title = summary || label;
        selectEl.appendChild(option);
      });

      const options = Array.from(selectEl.options || []);
      const hasPrevious = options.some((opt) => opt.value === previousValue);
      if(previousValue && hasPrevious){
        selectEl.value = previousValue;
      } else {
        selectEl.value = 'auto';
      }

      if(ctrl.manualInput){
        const manualCurrent = ctrl.select.value === 'manual'
          ? ctrl.manualInput.value.trim()
          : '';
        updateManualOptionLabel(ctrl, manualCurrent);
      } else {
        updateManualOptionLabel(ctrl, '');
      }
    }

    function determineDisplaySelectValue(storedValue){
      const trimmed = typeof storedValue === 'string' ? storedValue.trim() : '';
      if(!trimmed){
        return 'auto';
      }
      const targets = Array.isArray(displayTargetsState.list) ? displayTargetsState.list : [];
      const exists = targets.some((target) => target && target.value === trimmed);
      return exists ? trimmed : 'manual';
    }

    function applyDisplaySettingsData(data){
      if(!data){
        return;
      }
      lastDisplaySettings = data;

      ['assistant', 'display'].forEach((key) => {
        const ctrl = displayControls[key];
        if(!ctrl || !ctrl.select){
          return;
        }

        const info = data[key] && typeof data[key] === 'object' ? data[key] : {};
        const storedRaw = typeof info.stored === 'string' ? info.stored.trim() : '';
        const selectValue = determineDisplaySelectValue(storedRaw);

        if(ctrl.select.value !== selectValue){
          ctrl.select.value = selectValue;
          if(ctrl.select.value !== selectValue){
            ctrl.select.value = selectValue === 'manual' ? 'manual' : 'auto';
          }
        }

        toggleDisplayManualField(ctrl.manualField, ctrl.select.value === 'manual');

        if(ctrl.manualInput){
          if(ctrl.select.value === 'manual'){
            ctrl.manualInput.value = storedRaw;
          } else if(ctrl.select.value === 'auto'){
            ctrl.manualInput.value = '';
          } else {
            ctrl.manualInput.value = ctrl.select.value;
          }
          const manualLabelValue = ctrl.select.value === 'manual'
            ? (storedRaw || ctrl.manualInput.value || '')
            : '';
          updateManualOptionLabel(ctrl, manualLabelValue);
        }

        if(ctrl.status){
          let message = typeof info.message === 'string' && info.message.trim()
            ? info.message.trim()
            : ctrl.defaultStatus;
          if(storedRaw && selectValue === 'manual'){
            message = `${message} (tidigare vald skärm hittades inte i listan).`;
          }
          ctrl.status.textContent = message;
        }
      });
    }

    async function refreshDisplayTargets(showLoading = true){
      if(displayHelper && showLoading){
        displayHelper.textContent = 'Söker skärmar ...';
      }
      try {
        const res = await fetch('/api/display/targets');
        const data = await res.json();
        if(res.ok && data && data.ok){
          displayTargetsState.list = Array.isArray(data.targets) ? data.targets : [];
          if(displayHelper && typeof data.note === 'string'){
            displayHelper.textContent = data.note;
          }
          if(Array.isArray(data.warnings) && data.warnings.length){
            setDisplayStatus(data.warnings.join(' '));
          } else if(showLoading){
            setDisplayStatus('');
          }
        } else {
          displayTargetsState.list = [];
          const errorText = data && typeof data.error === 'string'
            ? data.error
            : 'Kunde inte hämta skärmar.';
          if(displayHelper){
            displayHelper.textContent = data && typeof data.note === 'string'
              ? data.note
              : 'Inga skärmar hittades automatiskt – ange värdet manuellt (t.ex. :0).';
          }
          setDisplayStatus(errorText);
        }
      } catch (err) {
        console.error('Kunde inte hämta display-targets', err);
        displayTargetsState.list = [];
        if(displayHelper){
          displayHelper.textContent = 'Kunde inte hämta skärmar. Ange värden manuellt.';
        }
        setDisplayStatus('Fel vid hämtning av skärmar.');
      }

      renderDisplayTargetsPreview();

      Object.values(displayControls).forEach((ctrl) => {
        if(ctrl && ctrl.select){
          populateDisplayOptions(ctrl);
        }
      });

      if(lastDisplaySettings){
        applyDisplaySettingsData(lastDisplaySettings);
      }
    }

    async function loadDisplayConfiguration(){
      setDisplayStatus('Hämtar skärminställningar ...');
      try {
        const res = await fetch('/api/display/settings');
        const data = await res.json();
        if(res.ok && data && data.ok){
          setDisplayStatus('');
          applyDisplaySettingsData(data);
        } else {
          const errorText = data && typeof data.error === 'string'
            ? data.error
            : 'Kunde inte hämta skärminställningar.';
          setDisplayStatus(errorText);
        }
      } catch (err) {
        console.error('Kunde inte hämta skärminställningar', err);
        setDisplayStatus('Kunde inte hämta skärminställningar.');
      }
    }

    function toggleAudioManualField(fieldEl, show){
      if(!fieldEl){
        return;
      }
      fieldEl.style.display = show ? '' : 'none';
    }

    function manualValueFromRaw(raw){
      if(typeof raw !== 'string'){
        return '';
      }
      if(raw.startsWith('manual:')){
        return raw.slice(7).trim();
      }
      return '';
    }

    function determineAudioOption(raw, fallback){
      if(typeof raw === 'string'){
        const trimmed = raw.trim();
        if(trimmed){
          if(trimmed.startsWith('manual:')){
            return 'manual';
          }
          return trimmed;
        }
      }
      return fallback || 'auto';
    }

    function populateAudioSelectOptions(ctrl, devices, selectedRaw, selectedOption){
      const selectEl = ctrl && ctrl.select;
      if(!selectEl){
        return;
      }

      const safeDevices = Array.isArray(devices) ? devices : [];
      const raw = typeof selectedRaw === 'string' ? selectedRaw : '';
      const option = typeof selectedOption === 'string' && selectedOption.trim()
        ? selectedOption.trim()
        : null;
      const manualValue = manualValueFromRaw(raw);
      const targetValue = option || determineAudioOption(raw, 'auto');

      selectEl.innerHTML = '';

      const autoOption = document.createElement('option');
      autoOption.value = 'auto';
      autoOption.textContent = 'Systemets standard';
      selectEl.appendChild(autoOption);

      const manualOption = document.createElement('option');
      manualOption.value = 'manual';
      manualOption.textContent = 'Ange manuellt värde ...';
      selectEl.appendChild(manualOption);

      const channelKey = ctrl.kind === 'output' ? 'maxOutputChannels' : 'maxInputChannels';

      safeDevices.forEach((device) => {
        const optionEl = document.createElement('option');
        const value = typeof device.value === 'string' && device.value.trim()
          ? device.value.trim()
          : `index:${device.index}`;
        optionEl.value = value;

        let label = '';
        if(typeof device.name === 'string' && device.name.trim()){
          label = device.name.trim();
        } else if(typeof device.index === 'number'){
          label = `Enhet ${device.index}`;
        } else {
          label = value;
        }

        const channels = typeof device[channelKey] === 'number' ? device[channelKey] : null;
        if(channels && channels > 0){
          label += ` – ${channels} kanal${channels === 1 ? '' : 'er'}`;
        }

        const hostapi = typeof device.hostapi === 'string' && device.hostapi.trim() ? device.hostapi.trim() : '';
        if(hostapi){
          label += ` (${hostapi})`;
        }

        if(device.isDefault){
          label += ' (systemstandard)';
        }

        optionEl.textContent = label;
        selectEl.appendChild(optionEl);
      });

      if(targetValue && targetValue !== 'auto' && targetValue !== 'manual'){
        const hasTarget = safeDevices.some((device) => {
          const value = typeof device.value === 'string' && device.value.trim()
            ? device.value.trim()
            : `index:${device.index}`;
          return value === targetValue;
        });
        if(!hasTarget){
          const fallbackOption = document.createElement('option');
          fallbackOption.value = targetValue;
          fallbackOption.textContent = `Tidigare vald: ${targetValue}`;
          fallbackOption.dataset.missing = '1';
          selectEl.appendChild(fallbackOption);
        }
      }

      selectEl.value = targetValue || 'auto';
      if(selectEl.value !== (targetValue || 'auto')){
        selectEl.value = targetValue === 'manual' ? 'manual' : 'auto';
      }

      toggleAudioManualField(ctrl.manualField, selectEl.value === 'manual');
      if(ctrl.manualInput){
        ctrl.manualInput.value = manualValue;
      }
    }

    function setAudioStatus(ctrl, text){
      if(!ctrl || !ctrl.status){
        return;
      }
      ctrl.status.textContent = text;
    }

    function applyAudioPayload(kind, payload, fallbackMessage){
      const ctrl = audioControls[kind];
      if(!ctrl){
        return;
      }

      const devices = payload && Array.isArray(payload.devices) ? payload.devices : [];
      const selectedRaw = payload && typeof payload.selected === 'string' ? payload.selected : '';
      const selectedOption = payload && typeof payload.selectedOption === 'string' ? payload.selectedOption : undefined;

      populateAudioSelectOptions(ctrl, devices, selectedRaw, selectedOption);

      let message = ctrl.defaultStatus;
      if(payload && typeof payload.message === 'string' && payload.message.trim()){
        message = payload.message.trim();
      } else if(fallbackMessage){
        message = fallbackMessage;
      }
      if(payload && typeof payload.error === 'string' && !payload.devicesOk){
        message = payload.error;
      }
      if(payload && typeof payload.devicesError === 'string'){
        message = payload.devicesError;
      }
      setAudioStatus(ctrl, message);
    }

    async function fetchAudioDevices(kind, showLoading = true){
      const ctrl = audioControls[kind];
      if(!ctrl || !ctrl.select){
        return;
      }
      if(showLoading){
        setAudioStatus(ctrl, ctrl.loadingText);
      }
      try {
        const res = await fetch(`/api/audio/${kind}-devices`);
        const data = await res.json();
        if(res.ok && data){
          applyAudioPayload(kind, data);
        } else {
          const errorText = data && typeof data.error === 'string'
            ? data.error
            : (kind === 'input'
              ? 'Kunde inte hämta ljudenheter.'
              : 'Kunde inte hämta ljudutgångar.');
          setAudioStatus(ctrl, errorText);
        }
      } catch (err) {
        console.error(kind === 'input' ? 'Kunde inte hämta ljudenheter' : 'Kunde inte hämta ljudutgångar', err);
        setAudioStatus(
          ctrl,
          kind === 'input' ? 'Kunde inte hämta ljudenheter.' : 'Kunde inte hämta ljudutgångar.'
        );
      }
    }

    async function loadAudioDevices(showLoading = true){
      await Promise.all([
        fetchAudioDevices('input', showLoading),
        fetchAudioDevices('output', showLoading)
      ]);
    }

    function renderLanLinks(urls, listEl){
      if(!listEl){
        return;
      }
      listEl.innerHTML = '';
      const safeUrls = Array.isArray(urls) ? urls : [];
      if(!safeUrls.length){
        const emptyItem = document.createElement('li');
        emptyItem.className = 'link-item';
        emptyItem.textContent = 'Inga adresser hittades.';
        listEl.appendChild(emptyItem);
        return;
      }

      safeUrls.forEach((url) => {
        const item = document.createElement('li');
        item.className = 'link-item';
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.target = '_blank';
        anchor.rel = 'noopener noreferrer';
        anchor.textContent = url;
        item.appendChild(anchor);

        if(clipboardAvailable){
          const copyBtn = document.createElement('button');
          copyBtn.type = 'button';
          copyBtn.className = 'copy-btn';
          copyBtn.textContent = 'Kopiera';
          copyBtn.addEventListener('click', async () => {
            try {
              await navigator.clipboard.writeText(url);
              flashLanStatus('Länken kopierades till urklipp.');
            } catch (err) {
              console.error('Kunde inte kopiera länken', err);
              flashLanStatus('Kunde inte kopiera länken.');
            }
          });
          item.appendChild(copyBtn);
        }

        listEl.appendChild(item);
      });
    }

    async function loadLanLinks(){
      if(!lanAdminList || !lanDisplayList){
        return;
      }
      setLanStatus('Söker tillgängliga adresser på nätverket ...');
      try {
        const res = await fetch('/api/network/lan-info');
        const data = await res.json();
        if(res.ok && data && data.ok){
          renderLanLinks(data.adminUrls || data.admin_urls || [], lanAdminList);
          renderLanLinks(data.displayUrls || data.display_urls || [], lanDisplayList);
          const lanAddresses = Array.isArray(data.lanAddresses) ? data.lanAddresses : [];
          let message = typeof data.note === 'string' && data.note.trim()
            ? data.note.trim()
            : 'Öppna länkarna från en annan enhet på samma nätverk.';
          if(!lanAddresses.length && (!Array.isArray(data.baseUrls) || !data.baseUrls.length)){
            message = 'Kunde inte hitta några adresser automatiskt. Använd adressen du redan har öppnat.';
          }
          setLanStatus(message, true);
        } else {
          const errorText = data && data.error ? data.error : 'Kunde inte hämta nätverksadresser.';
          setLanStatus(errorText, true);
          renderLanLinks([], lanAdminList);
          renderLanLinks([], lanDisplayList);
        }
      } catch (err) {
        console.error('Kunde inte hämta nätverksinformation', err);
        setLanStatus('Kunde inte hämta nätverksadresser.', true);
        renderLanLinks([], lanAdminList);
        renderLanLinks([], lanDisplayList);
      }
    }

    function updateNameFromBuilder(){
      const parts = [namePrefix.value.trim(), nameCore.value.trim(), nameSuffix.value.trim()].filter(Boolean);
      if(parts.length){
        assistantNameInput.value = parts.join(' ');
      }
      updateNamePreview();
    }

    function updateNamePreview(){
      const value = assistantNameInput.value.trim();
      assistantPreview.textContent = value || '—';
    }

    document.querySelectorAll('[data-name-part]').forEach((btn) => {
      btn.addEventListener('click', () => {
        const part = btn.getAttribute('data-name-part');
        const value = btn.getAttribute('data-value');
        if(part === 'prefix') namePrefix.value = value;
        if(part === 'core') nameCore.value = value;
        if(part === 'suffix') nameSuffix.value = value;
        updateNameFromBuilder();
      });
    });

    [namePrefix, nameCore, nameSuffix].forEach((input) => {
      input.addEventListener('input', updateNameFromBuilder);
    });

    assistantNameInput.addEventListener('input', updateNamePreview);

    if(backgroundUploadInput){
      backgroundUploadInput.addEventListener('change', async () => {
        const file = backgroundUploadInput.files && backgroundUploadInput.files[0];
        if(!file){
          return;
        }

        if(backgroundUploadFeedback){
          backgroundUploadFeedback.textContent = 'Laddar upp bakgrundsbild ...';
        }

        const formData = new FormData();
        formData.append('file', file);

        let resetFeedback = true;
        try {
          const res = await fetch('/api/ui-settings/background-image', {
            method: 'POST',
            body: formData
          });
          const data = await res.json();
          if(res.ok && data.ok){
            backgroundInput.value = data.backgroundImage || '';
            if(backgroundUploadFeedback){
              backgroundUploadFeedback.textContent = 'Bakgrundsbilden är uppladdad och sparad.';
            }
            if(appearanceStatus){
              appearanceStatus.textContent = 'Bakgrundsbilden är uppladdad och sparad.';
            }
          } else {
            if(backgroundUploadFeedback){
              backgroundUploadFeedback.textContent = data.error || 'Kunde inte ladda upp bilden.';
            }
            resetFeedback = false;
          }
        } catch (err) {
          console.error('Uppladdning av bakgrundsbild misslyckades', err);
          if(backgroundUploadFeedback){
            backgroundUploadFeedback.textContent = 'Ett fel inträffade vid uppladdningen.';
          }
          resetFeedback = false;
        } finally {
          backgroundUploadInput.value = '';
          if(resetFeedback && backgroundUploadFeedback){
            setTimeout(() => {
              backgroundUploadFeedback.textContent = backgroundUploadDefaultText;
            }, 4000);
          }
        }
      });
    }

    async function loadSettings(){
      try {
        const res = await fetch('/api/ui-settings');
        const data = await res.json();
        if(res.ok && data.ok && data.settings){
          applySettingsToForm(data.settings);
        } else {
          applySettingsToForm(defaultSettings);
        }
      } catch (err) {
        console.error('Kunde inte läsa inställningar', err);
        applySettingsToForm(defaultSettings);
      }
    }

    function applySettingsToForm(settings){
      const merged = { ...defaultSettings, ...settings };
      assistantNameInput.value = merged.assistantName || defaultSettings.assistantName;
      backgroundInput.value = merged.backgroundImage || '';
      fontInput.value = merged.fontFamily || defaultSettings.fontFamily;
      primaryColorInput.value = merged.primaryButtonColor || defaultSettings.primaryButtonColor;
      secondaryColorInput.value = merged.secondaryButtonColor || defaultSettings.secondaryButtonColor;
      buttonTextColorInput.value = merged.buttonTextColor || defaultSettings.buttonTextColor;
      updateNamePreview();
    }

    Object.values(displayControls).forEach((ctrl) => {
      if(!ctrl || !ctrl.select){
        return;
      }
      const manualOption = ctrl.select ? ctrl.select.querySelector('option[value="manual"]') : null;
      if(manualOption && !ctrl.manualOption){
        ctrl.manualOption = manualOption;
        ctrl.manualDefaultLabel = manualOption.textContent;
      }

      ctrl.select.addEventListener('change', () => {
        const value = ctrl.select.value;
        toggleDisplayManualField(ctrl.manualField, value === 'manual');
        if(ctrl.manualInput){
          if(value === 'manual'){
            if(!ctrl.manualInput.value){
              ctrl.manualInput.focus();
            }
            updateManualOptionLabel(ctrl, ctrl.manualInput.value.trim());
          } else if(value === 'auto'){
            ctrl.manualInput.value = '';
            updateManualOptionLabel(ctrl, '');
          } else {
            ctrl.manualInput.value = value;
            updateManualOptionLabel(ctrl, '');
          }
        }
      });
      toggleDisplayManualField(ctrl.manualField, ctrl.select.value === 'manual');
      if(ctrl.manualInput){
        ctrl.manualInput.addEventListener('input', () => {
          if(ctrl.select.value === 'manual'){
            updateManualOptionLabel(ctrl, ctrl.manualInput.value.trim());
          }
        });
      }
      const initialManualValue = ctrl.select.value === 'manual' && ctrl.manualInput
        ? ctrl.manualInput.value.trim()
        : '';
      updateManualOptionLabel(ctrl, initialManualValue);
    });

    if(displayRefreshBtn){
      displayRefreshBtn.addEventListener('click', () => {
        refreshDisplayTargets(true);
      });
    }

    if(displayForm){
      displayForm.addEventListener('submit', async (ev) => {
        ev.preventDefault();

        const assistantCtrl = displayControls.assistant;
        const displayCtrl = displayControls.display;

        if(!assistantCtrl || !assistantCtrl.select || !displayCtrl || !displayCtrl.select){
          return;
        }

        const payload = {
          assistantChoice: assistantCtrl.select.value,
          assistantManual: assistantCtrl.manualInput ? assistantCtrl.manualInput.value.trim() : '',
          displayChoice: displayCtrl.select.value,
          displayManual: displayCtrl.manualInput ? displayCtrl.manualInput.value.trim() : ''
        };

        if(payload.assistantChoice === 'manual' && !payload.assistantManual){
          setDisplayStatus('Ange ett manuellt värde för assistentens skärm.');
          if(assistantCtrl.manualInput){
            assistantCtrl.manualInput.focus();
          }
          return;
        }

        if(payload.displayChoice === 'manual' && !payload.displayManual){
          setDisplayStatus('Ange ett manuellt värde för visningslägets skärm.');
          if(displayCtrl.manualInput){
            displayCtrl.manualInput.focus();
          }
          return;
        }

        setDisplayStatus('Sparar skärmar ...');

        try {
          const res = await fetch('/api/display/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await res.json();
          if(res.ok && data && data.ok){
            setDisplayStatus('Skärmar sparade.');
            applyDisplaySettingsData(data);
          } else {
            const errorText = data && typeof data.error === 'string'
              ? data.error
              : 'Kunde inte spara skärmarna.';
            setDisplayStatus(errorText);
            const field = data && typeof data.field === 'string' ? data.field : '';
            if(field === 'assistant' && assistantCtrl.manualInput){
              assistantCtrl.manualInput.focus();
            } else if(field === 'display' && displayCtrl.manualInput){
              displayCtrl.manualInput.focus();
            }
          }
        } catch (err) {
          console.error('Kunde inte spara skärmar', err);
          setDisplayStatus('Ett fel inträffade vid sparande av skärmar.');
        }
      });
    }

    Object.values(audioControls).forEach((ctrl) => {
      if(!ctrl || !ctrl.select){
        return;
      }
      ctrl.select.addEventListener('change', () => {
        const isManual = ctrl.select.value === 'manual';
        toggleAudioManualField(ctrl.manualField, isManual);
        if(isManual && ctrl.manualInput){
          ctrl.manualInput.focus();
        }
      });
      toggleAudioManualField(ctrl.manualField, ctrl.select.value === 'manual');
    });

    if(audioRefreshBtn){
      audioRefreshBtn.addEventListener('click', () => {
        loadAudioDevices(false);
      });
    }

    if(audioForm){
      audioForm.addEventListener('submit', async (ev) => {
        ev.preventDefault();

        const inputCtrl = audioControls.input;
        const outputCtrl = audioControls.output;

        if(!inputCtrl.select && !outputCtrl.select){
          return;
        }

        const payload = {};

        if(inputCtrl && inputCtrl.select){
          const inputChoice = inputCtrl.select.value;
          let inputManual = '';
          if(inputChoice === 'manual'){
            inputManual = inputCtrl.manualInput ? inputCtrl.manualInput.value.trim() : '';
            if(!inputManual){
              setAudioStatus(inputCtrl, 'Ange en manuell ljudkälla.');
              if(inputCtrl.manualInput){
                inputCtrl.manualInput.focus();
              }
              return;
            }
          } else if(inputChoice.startsWith('manual:')){
            inputManual = inputCtrl.manualInput ? inputCtrl.manualInput.value.trim() : '';
          }
          payload.inputDevice = inputChoice;
          payload.manualValue = inputManual;
        }

        if(outputCtrl && outputCtrl.select){
          const outputChoice = outputCtrl.select.value;
          let outputManual = '';
          if(outputChoice === 'manual'){
            outputManual = outputCtrl.manualInput ? outputCtrl.manualInput.value.trim() : '';
            if(!outputManual){
              setAudioStatus(outputCtrl, 'Ange en manuell ljudutgång.');
              if(outputCtrl.manualInput){
                outputCtrl.manualInput.focus();
              }
              return;
            }
          } else if(outputChoice.startsWith('manual:')){
            outputManual = outputCtrl.manualInput ? outputCtrl.manualInput.value.trim() : '';
          }
          payload.outputDevice = outputChoice;
          payload.outputManualValue = outputManual;
        }

        setAudioStatus(audioControls.input, 'Sparar ljudenheter ...');
        setAudioStatus(audioControls.output, 'Sparar ljudenheter ...');

        try {
          const res = await fetch('/api/audio/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await res.json();
          if(res.ok && data){
            if(data.input){
              applyAudioPayload('input', data.input, 'Ljudenhet sparad.');
            }
            if(data.output){
              applyAudioPayload('output', data.output, 'Ljudenhet sparad.');
            }
          } else {
            const errMsg = data && typeof data.error === 'string' ? data.error : 'Kunde inte spara ljudenheter.';
            const field = data && typeof data.field === 'string' ? data.field : '';
            if(field === 'output'){
              setAudioStatus(audioControls.output, errMsg);
            } else if(field === 'input'){
              setAudioStatus(audioControls.input, errMsg);
            } else {
              setAudioStatus(audioControls.input, errMsg);
              setAudioStatus(audioControls.output, errMsg);
            }
          }
        } catch (err) {
          console.error('Kunde inte spara ljudenheter', err);
          setAudioStatus(audioControls.input, 'Ett fel inträffade vid sparande av ljudenheter.');
          setAudioStatus(audioControls.output, 'Ett fel inträffade vid sparande av ljudenheter.');
        }
      });
    }

    appearanceForm.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const payload = {
        assistantName: assistantNameInput.value.trim() || defaultSettings.assistantName,
        backgroundImage: backgroundInput.value.trim(),
        fontFamily: fontInput.value.trim() || defaultSettings.fontFamily,
        primaryButtonColor: primaryColorInput.value,
        secondaryButtonColor: secondaryColorInput.value,
        buttonTextColor: buttonTextColorInput.value
      };

      appearanceStatus.textContent = 'Sparar inställningar ...';
      try {
        const res = await fetch('/api/ui-settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if(res.ok && data.ok){
          appearanceStatus.textContent = 'Inställningarna är sparade.';
        } else {
          appearanceStatus.textContent = data.error || 'Kunde inte spara inställningarna.';
        }
      } catch (err){
        appearanceStatus.textContent = 'Ett fel inträffade vid sparande.';
        console.error(err);
      }
    });

    function pushLog(message, type = 'info', meta = ''){
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`.trim();
      entry.textContent = message;
      if(meta){
        const small = document.createElement('small');
        small.textContent = meta;
        entry.appendChild(small);
      }
      log.prepend(entry);
    }

    ragForm.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const raw = ragInput.value.trim();
      if(!raw){
        ragInput.focus();
        return;
      }

      const sources = raw.split(/\n+/).map((s) => s.trim()).filter(Boolean);
      if(!sources.length){
        ragInput.focus();
        return;
      }

      statusEl.textContent = 'Indexerar källor ...';
      ragSubmit.disabled = true;
      ragReset.disabled = true;
      ragInput.disabled = true;
      try {
        const res = await fetch('/api/rag/ingest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sources })
        });
        const data = await res.json();
        if(res.ok && data.ok){
          const added = typeof data.chunks_added === 'number' ? data.chunks_added : 'okänt antal';
          statusEl.textContent = `Indexerade ${added} textdelar.`;
          pushLog(`Källa${sources.length > 1 ? 'r' : ''} indexerade.`, 'success', sources.join('\n'));
          ragInput.value = '';
        } else {
          const error = data.error || 'Kunde inte indexera källorna.';
          statusEl.textContent = error;
          pushLog(error, 'error', sources.join('\n'));
        }
      } catch (err){
        statusEl.textContent = 'Fel: ' + err;
        pushLog('Ett fel inträffade vid indexering.', 'error');
      } finally {
        ragSubmit.disabled = false;
        ragReset.disabled = false;
        ragInput.disabled = false;
        ragInput.focus();
      }
    });

    ragReset.addEventListener('click', async () => {
      if(!confirm('Är du säker på att du vill rensa kunskapsbasen?')){
        return;
      }
      statusEl.textContent = 'Rensar kunskapsbas ...';
      ragSubmit.disabled = true;
      ragReset.disabled = true;
      ragInput.disabled = true;
      try {
        const res = await fetch('/api/rag/reset', { method: 'POST' });
        const data = await res.json();
        if(res.ok && data.ok){
          statusEl.textContent = 'Kunskapsbasen är rensad.';
          pushLog('Kunskapsbasen rensades.', 'success');
        } else {
          const error = data.error || 'Kunde inte rensa kunskapsbasen.';
          statusEl.textContent = error;
          pushLog(error, 'error');
        }
      } catch (err){
        statusEl.textContent = 'Fel: ' + err;
        pushLog('Ett fel inträffade vid rensning.', 'error');
      } finally {
        ragSubmit.disabled = false;
        ragReset.disabled = false;
        ragInput.disabled = false;
      }
    });

    // Wake word settings functionality
    async function loadWakeWordSettings() {
      if (!wakeWordForm) return;
      
      try {
        const res = await fetch('/api/wake-word/settings');
        const settings = await res.json();
        
        if (wakeWordEnabled) wakeWordEnabled.checked = settings.enabled || false;
        if (wakeWordsInput) wakeWordsInput.value = (settings.wakeWords || []).join(', ');
        if (wakeWordTimeout) wakeWordTimeout.value = settings.timeout || 5.0;
        if (wakeWordCooldown) wakeWordCooldown.value = settings.cooldown || 1.0;
        
        if (wakeWordStatus) {
          wakeWordStatus.textContent = settings.enabled ? 
            'Wake word-detektering är aktiverad.' : 
            'Wake word-detektering är avaktiverad.';
        }
      } catch (err) {
        console.error('Failed to load wake word settings:', err);
        if (wakeWordStatus) {
          wakeWordStatus.textContent = 'Kunde inte ladda wake word-inställningar.';
        }
      }
    }

    if (wakeWordForm) {
      wakeWordForm.addEventListener('submit', async (ev) => {
        ev.preventDefault();
        
        if (!wakeWordStatus) return;
        
        const wakeWordsText = wakeWordsInput ? wakeWordsInput.value.trim() : '';
        const wakeWords = wakeWordsText ? wakeWordsText.split(',').map(w => w.trim()).filter(w => w) : [];
        
        const payload = {
          enabled: wakeWordEnabled ? wakeWordEnabled.checked : false,
          wakeWords: wakeWords,
          timeout: wakeWordTimeout ? parseFloat(wakeWordTimeout.value) : 5.0,
          cooldown: wakeWordCooldown ? parseFloat(wakeWordCooldown.value) : 1.0
        };

        wakeWordStatus.textContent = 'Sparar wake word-inställningar ...';
        
        try {
          const res = await fetch('/api/wake-word/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await res.json();
          
          if (res.ok && data.ok) {
            wakeWordStatus.textContent = payload.enabled ? 
              'Wake word-inställningar sparade och aktiverade.' : 
              'Wake word-inställningar sparade och avaktiverade.';
          } else {
            wakeWordStatus.textContent = data.error || 'Kunde inte spara wake word-inställningar.';
          }
        } catch (err) {
          wakeWordStatus.textContent = 'Ett fel inträffade vid sparande.';
          console.error('Wake word settings error:', err);
        }
      });
    }

    refreshDisplayTargets();
    loadDisplayConfiguration();
    loadAudioDevices();
    loadWakeWordSettings();
    loadLanLinks();
    loadSettings();
    
    // MCP Management
    const mcpEnabled = document.getElementById('mcp-enabled');
    const mcpServersSection = document.getElementById('mcp-servers-section');
    const mcpServersList = document.getElementById('mcp-servers-list');
    const mcpAddServerForm = document.getElementById('mcp-add-server-form');
    const mcpServerName = document.getElementById('mcp-server-name');
    const mcpServerCommand = document.getElementById('mcp-server-command');
    const mcpServerArgs = document.getElementById('mcp-server-args');
    const mcpServerEnv = document.getElementById('mcp-server-env');
    const mcpSaveBtn = document.getElementById('mcp-save');
    const mcpStatus = document.getElementById('mcp-status');
    
    let mcpServers = {};
    
    mcpEnabled.addEventListener('change', () => {
      if(mcpEnabled.checked){
        mcpServersSection.style.display = 'block';
      } else {
        mcpServersSection.style.display = 'none';
      }
    });
    
    async function loadMCPSettings(){
      try {
        const res = await fetch('/api/mcp/settings');
        const data = await res.json();
        
        if(res.ok && data.ok){
          mcpEnabled.checked = data.enabled || false;
          mcpServers = data.servers || {};
          
          if(mcpEnabled.checked){
            mcpServersSection.style.display = 'block';
          }
          
          renderMCPServers();
          mcpStatus.textContent = 'MCP-inställningar laddade.';
        } else {
          mcpStatus.textContent = data.error || 'Kunde inte ladda MCP-inställningar.';
        }
      } catch (err){
        console.error('Failed to load MCP settings:', err);
        mcpStatus.textContent = 'Ett fel inträffade vid laddning av MCP-inställningar.';
      }
    }
    
    function renderMCPServers(){
      if(Object.keys(mcpServers).length === 0){
        mcpServersList.innerHTML = '<p style="opacity:0.75;">Inga servrar konfigurerade.</p>';
        return;
      }
      
      mcpServersList.innerHTML = '';
      for(const [name, config] of Object.entries(mcpServers)){
        const serverCard = document.createElement('div');
        serverCard.style.cssText = 'padding:16px; border-radius:14px; background:rgba(15,30,55,0.6); border:1px solid rgba(62,96,146,0.4);';
        
        const serverName = document.createElement('div');
        serverName.style.cssText = 'font-weight:600; font-size:18px; margin-bottom:8px;';
        serverName.textContent = name;
        
        const serverCommand = document.createElement('div');
        serverCommand.style.cssText = 'font-size:14px; opacity:0.85; margin-bottom:4px;';
        serverCommand.textContent = `Kommando: ${config.command}`;
        
        const serverArgs = document.createElement('div');
        serverArgs.style.cssText = 'font-size:14px; opacity:0.85; margin-bottom:4px;';
        serverArgs.textContent = `Argument: ${config.args.length > 0 ? config.args.join(' ') : 'Inga'}`;
        
        const serverEnv = document.createElement('div');
        serverEnv.style.cssText = 'font-size:14px; opacity:0.85; margin-bottom:12px;';
        const envKeys = Object.keys(config.env || {});
        serverEnv.textContent = `Miljövariabler: ${envKeys.length > 0 ? envKeys.join(', ') : 'Inga'}`;
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn danger';
        removeBtn.textContent = 'Ta bort';
        removeBtn.style.cssText = 'font-size:14px; padding:8px 16px;';
        removeBtn.onclick = () => removeMCPServer(name);
        
        serverCard.appendChild(serverName);
        serverCard.appendChild(serverCommand);
        serverCard.appendChild(serverArgs);
        serverCard.appendChild(serverEnv);
        serverCard.appendChild(removeBtn);
        
        mcpServersList.appendChild(serverCard);
      }
    }
    
    function removeMCPServer(name){
      if(confirm(`Är du säker på att du vill ta bort servern "${name}"?`)){
        delete mcpServers[name];
        renderMCPServers();
        mcpStatus.textContent = `Server "${name}" borttagen. Glöm inte att spara.`;
      }
    }
    
    mcpAddServerForm.addEventListener('submit', (ev) => {
      ev.preventDefault();
      
      const name = mcpServerName.value.trim();
      const command = mcpServerCommand.value.trim();
      const argsText = mcpServerArgs.value.trim();
      const envText = mcpServerEnv.value.trim();
      
      if(!name || !command){
        mcpStatus.textContent = 'Servernamn och kommando krävs.';
        return;
      }
      
      if(mcpServers[name]){
        mcpStatus.textContent = `En server med namnet "${name}" finns redan.`;
        return;
      }
      
      const args = argsText.split('\n').map(l => l.trim()).filter(l => l);
      let env = {};
      
      if(envText){
        try {
          env = JSON.parse(envText);
        } catch (err){
          mcpStatus.textContent = 'Ogiltigt JSON-format för miljövariabler.';
          return;
        }
      }
      
      mcpServers[name] = { command, args, env };
      renderMCPServers();
      
      mcpServerName.value = '';
      mcpServerCommand.value = '';
      mcpServerArgs.value = '';
      mcpServerEnv.value = '';
      
      mcpStatus.textContent = `Server "${name}" tillagd. Glöm inte att spara.`;
    });
    
    mcpSaveBtn.addEventListener('click', async () => {
      mcpStatus.textContent = 'Sparar MCP-inställningar ...';
      
      try {
        const res = await fetch('/api/mcp/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            enabled: mcpEnabled.checked,
            servers: mcpServers
          })
        });
        
        const data = await res.json();
        
        if(res.ok && data.ok){
          mcpStatus.textContent = data.message || 'MCP-inställningar sparade.';
        } else {
          mcpStatus.textContent = data.error || 'Kunde inte spara MCP-inställningar.';
        }
      } catch (err){
        console.error('Failed to save MCP settings:', err);
        mcpStatus.textContent = 'Ett fel inträffade vid sparande av MCP-inställningar.';
      }
    });
    
    loadMCPSettings();
  </script>
</body>
</html>
